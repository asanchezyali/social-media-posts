\documentclass[12pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[letterpaper, margin=1in, bottom=2.5in, top=2.2in]{geometry}
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\setlength{\footskip}{72pt}

\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{anyfontsize}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\usepackage{sourcesanspro}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{fontawesome5}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{mdframed}
\usepackage{qrcode} % Add package to generate QR codes
\usetikzlibrary{calc,shapes,positioning}
\usepackage{eso-pic}

\AtBeginDocument{\color{primaryColor}}

% Colors updated with JavaScript brand colors
\definecolor{bgColor}{RGB}{13, 17, 23}  % Dark background similar to JS docs
\definecolor{primaryColor}{RGB}{255, 255, 255}  % White text for better contrast
\definecolor{accentColor}{RGB}{255, 220, 60}  % Brighter JavaScript Yellow for better contrast
\definecolor{jsSecondary}{RGB}{180, 180, 180}  % Light gray as secondary color for better contrast
\definecolor{secondaryColor}{RGB}{230, 235, 240}  % Almost white gray for better contrast
\definecolor{terminalBg}{RGB}{22, 22, 22}  % Terminal background
\definecolor{terminalFrame}{RGB}{40, 40, 40}  % Terminal frame
\definecolor{lineNumberColor}{RGB}{100, 100, 100}  % Line number color
\definecolor{dividerColor}{RGB}{120, 130, 150}  % Brighter divider color for better visibility

% Colors for code
\definecolor{codeTextColor}{RGB}{255, 255, 255}  % Pure white for basic text
\definecolor{codeKeywordColor}{RGB}{97, 175, 239}  % Light blue for keywords
\definecolor{codeCommentColor}{RGB}{121, 192, 120}  % Green for comments
\definecolor{codeStringColor}{RGB}{255, 220, 60}  % Brighter JS yellow for strings
\definecolor{codeMethodColor}{RGB}{255, 160, 122}  % Light orange for methods
\definecolor{codeFunctionColor}{RGB}{230, 180, 80}  % Yellow-gold tone for functions
\definecolor{codeNumberColor}{RGB}{180, 230, 180}  % Light green for numbers

\pagecolor{bgColor}

\hypersetup{
    colorlinks=true,
    linkcolor=accentColor,
    filecolor=accentColor,
    urlcolor=accentColor,
}

% Define JavaScript language for listings
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, let, const, class, export, import, yield, async, await, Promise, resolve, reject, then, catch, finally, all, race, allSettled, any},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]"
}

% Configuration for listings with JavaScript as default language
\lstset{
  language=JavaScript,
  basicstyle=\ttfamily\bfseries\color{codeTextColor},
  backgroundcolor=\color{terminalBg},
  commentstyle=\color{codeCommentColor},
  keywordstyle=\color{codeKeywordColor},
  stringstyle=\color{codeStringColor},
  numberstyle=\color{lineNumberColor},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  showstringspaces=false,
  frame=none,
  xleftmargin=15pt,
  xrightmargin=0pt,
  aboveskip=5pt,
  belowskip=5pt,
  numbers=left,
  numbersep=8pt,
  extendedchars=true,
  keepspaces=true,
  columns=flexible,
  lineskip=2pt,
  emph={[2]require,createReadStream,createWriteStream,pipe,on,once,createGzip,pipeline,Transform,Readable,Writable,Duplex, setTimeout, console, Error, Math, JSON}, % Added common JS built-ins
  emphstyle={[2]\color{codeFunctionColor}}
}

\newenvironment{macterminal}{%
    \begin{mdframed}[
        linecolor=terminalFrame,
        backgroundcolor=terminalBg,
        roundcorner=5pt,
        skipabove=5pt,
        skipbelow=5pt,
        linewidth=1pt,
        innertopmargin=5pt,
        frametitle={%
            \tikz[baseline=(current bounding box.east), outer sep=0pt]{
                \fill[red!80!black] (0,0) circle (5pt);
                \fill[yellow!80!black] (0.7,0) circle (5pt);
                \fill[green!70!black] (1.4,0) circle (5pt);
            }
        },
        frametitlealignment=\raggedright,
        frametitleaboveskip=8pt,
        frametitlebelowskip=0pt,
    ]
}{%
    \end{mdframed}%
}

\newcommand{\verspace}{\vspace{5pt}}

\titleformat{\section}
  {\LARGE\bfseries\color{primaryColor}}
  {\thesection. }
  {0pt}
  {}
  []

\titleformat{\subsection}
  {\Large\bfseries\color{accentColor}}
  {\thesubsection. }
  {0pt}
  {}
  []

\titleformat{\subsubsection}
  {\large\bfseries\color{primaryColor}}
  {\thesubsubsection. }
  {0pt}
  {}
  []

\titlespacing*{\section}{0pt}{18pt}{8pt}
\titlespacing*{\subsection}{0pt}{12pt}{5pt}
\titlespacing*{\subsubsection}{0pt}{8pt}{3pt}

\pagestyle{fancy}
\fancyhf{}

\fancyhead[L]{
    \begin{tikzpicture}[remember picture, overlay]
        \fill[accentColor, rounded corners=3pt] (0,0) rectangle (2.2cm,0.7cm);
        \node[text=bgColor, font=\bfseries] at (1.1cm,0.35cm) {NODE.JS};
        \fill[secondaryColor] (2.35cm,0.1cm) rectangle (2.40cm,0.6cm);
        \node[text=primaryColor, font=\bfseries, anchor=west] at (2.35cm,0.35cm) {PROMISES};
    \end{tikzpicture}
}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0.2pt}
\renewcommand{\footruleskip}{1cm}

\fancyfoot[C]{
    \vspace*{0.1cm}
    \noindent
    \begin{minipage}{\textwidth}
        \begin{flushleft}
            % Profile photo
            \raisebox{0.7cm}{
            \begin{tikzpicture}[baseline]
                \path[fill=bgColor] (0,0) circle (0.6cm);
                \clip (0,0) circle (0.6cm);
                \node at (0,0) {
                    \includegraphics[width=1.2cm,height=1.2cm]{../../Images/profile-image.jpeg}
                };
            \end{tikzpicture}
            }
            % Profile information
            \begin{minipage}[b]{0.5\textwidth}
                {\large\bfseries\color{primaryColor}Alejandro Sánchez Yalí}
                \par\vspace{1pt}
                {\small\color{secondaryColor}Software Developer | AI \& Blockchain Enthusiast}
                \par\vspace{1pt}
                {\small\color{accentColor}\faGlobe\hspace{5pt}\color{secondaryColor}www.asanchezyali.com}
            \end{minipage}
        \end{flushleft}
        \vspace{6pt}
    \end{minipage}
}

\fancypagestyle{plain}{
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \renewcommand{\footrulewidth}{0pt}
}

\renewcommand{\labelitemi}{\textcolor{accentColor}{$\bullet$}}
\renewcommand{\labelitemii}{\textcolor{secondaryColor}{$\circ$}}

\usepackage{relsize}
\AtBeginDocument{\relsize{1}}

\newcommand{\languagetag}[1]{
    \begin{tikzpicture}[baseline]
        \node[fill=accentColor, text=bgColor, rounded corners=5pt, inner sep=7pt] {
            {\normalsize\textbf{#1}}
        };
    \end{tikzpicture}
}

\newcommand{\BackgroundPic}{%
    \put(0,0){%
        \begin{tikzpicture}[remember picture, overlay]
            % Place the background image covering the entire page
            \node[inner sep=0pt] at (current page.center) {
                \includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio=false]{../../Images/Intense Focus at Gaming Event.jpeg}
            };
            
            % Add a semi-transparent dark layer over the image
            % You can adjust the color and opacity as needed
            \fill[black, opacity=0.7] (current page.south west) rectangle (current page.north east);
            
            % If you want a dark gradient instead of a solid color, use this:
            % \shade[top color=black!80, bottom color=black!40, opacity=0.7] 
            %    (current page.south west) rectangle (current page.north east);
        \end{tikzpicture}%
    }%
}

% Command for elegant QR (for the title page)
\newcommand{\elegantqr}[2]{
    \qrcode[height=2.5cm]{#1}
    \\[0.1cm]
    {\hspace{0.2cm}\color{primaryColor}\small #2\par}
}

\newcommand{\titlepagecontents}{%
    \AddToShipoutPicture*{\BackgroundPic}
    \vspace*{2cm}
    \begin{flushleft}
    \languagetag{JavaScript}\\[0.4cm] % Use JS tag
    {\fontsize{38}{52}\bfseries\color{primaryColor}Understanding \color{accentColor}JavaScript\\\color{accentColor}Promises\par}
    \vspace{0.3cm}
    {\fontsize{18}{52}\color{secondaryColor}Handling Asynchronous Operations Like a Pro \\ Part 2/3\par}
    \vspace{0.3cm}
    {\color{secondaryColor}\today\par}
    \vspace{1.8cm}
    \elegantqr{https://github.com/asanchezyali/social-media-posts/tree/main/JavaScript/Promises}{Source Code}
    \end{flushleft}
}

\newcommand{\finalpagecontents}{%
    \AddToShipoutPicture*{\BackgroundPic}
    \vspace*{3cm}
    % Left-aligned elements with EXACT same structure as title page
    \begin{flushleft}
    \languagetag{Feedback}\\[0.4cm]
    {\fontsize{46}{52}\bfseries\color{primaryColor}Found this \color{accentColor}helpful?\par}
    \vspace{0.3cm}
    {\fontsize{18}{52}\color{secondaryColor}Save, comment and share\par}  
    \vspace{0.3cm}
    {\color{secondaryColor}\today\par}
    \end{flushleft}
}

\begin{document}
\setlength{\parindent}{0pt}
\begin{titlepage}
    \titlepagecontents
\end{titlepage}

\section{Chaining Promises: Building Complex Async Flows}

In the first part of this series, we learned how to create and handle basic promises. Now, we'll dive into more advanced techniques that reveal the full potential of promises in JavaScript.

One of the most powerful features of promises is the ability to chain them together to create elegant complex asynchronous flows.

\subsection{The Power of Chaining}

When we use the \texttt{\textcolor{accentColor}{.then()}} method, it returns a new promise that resolves with the value returned by the provided callback function. This allows us to chain multiple asynchronous operations sequentially, passing data from one to the next.

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|03_promise_chaining.js|.
    \item Open your terminal and run: \verb|node 03_promise_chaining.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 03_promise_chaining.js ---
// Simulates retrieving a user ID from a database
function getUserId(username) {
  console.log(`Looking up ID for user: ${username}...`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // Simulates database lookup
      if (username.toLowerCase() === 'alejandro') {
        resolve(123);
      } else {
        reject(new Error('User not found'));
      }
    }, 1000);
  });
}

// Simulates retrieving profile details based on an ID
function getUserProfile(userId) {
  console.log(`Getting profile for ID: ${userId}...`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // Simulates database lookup
      resolve({
        id: userId,
        name: 'Alejandro',
        role: 'Developer',
        city: 'Medellin'
      });
    }, 1000);
  });
}

// Simulates checking permissions for a profile
function checkPermissions(userProfile) {
  console.log(`Verifying permissions for: ${userProfile.name}...`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (userProfile.role === 'Developer') {
        resolve({
          ...userProfile,
          permissions: ['read', 'write', 'deploy']
        });
      } else {
        resolve({
          ...userProfile,
          permissions: ['read']
        });
      }
    }, 800);
  });
}

// Using promise chaining
console.log("Starting authentication flow...");
getUserId('Alejandro')
  .then(userId => {
    console.log(`User ID found: ${userId}`);
    return getUserProfile(userId); // Returns a new promise
  })
  .then(userProfile => {
    console.log(`Profile obtained:`, userProfile);
    return checkPermissions(userProfile); // Returns another promise
  })
  .then(profileWithPermissions => {
    console.log(`Authentication complete!`);
    console.log(`User ${profileWithPermissions.name} has permissions: ${profileWithPermissions.permissions.join(', ')}`);
  })
  .catch(error => {
    console.error(`Error in process: ${error.message}`);
  })
  .finally(() => {
    console.log("Authentication process finished.");
  });

console.log("Code continues to run while promises resolve...");
\end{lstlisting}
\end{macterminal}

\textbf{Key points:}
\begin{itemize}
    \item Each \texttt{\textcolor{accentColor}{.then()}} receives the result of the previous one and can return a new value or promise.
    \item Chaining is sequential: each operation waits for the previous one to complete.
    \item A single \texttt{\textcolor{accentColor}{.catch()}} can capture errors from any part of the chain.
    \item Return values are handled automatically: if we return a simple value, it's automatically wrapped in a resolved promise.
\end{itemize}

\section{Managing Multiple Promises in Parallel}

In many situations, we need to execute multiple asynchronous operations simultaneously and react when they all complete or when any fails. JavaScript provides static methods in the Promise class for these scenarios.

\subsection{Promise.all(): Waiting for Everything to Complete}

When we need to run multiple operations in parallel and wait for all of them to complete, \texttt{\textcolor{accentColor}{Promise.all()}} is the ideal tool.

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|04_promise_all.js|.
    \item Open your terminal and run: \verb|node 04_promise_all.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 04_promise_all.js ---
// Simulates API requests for different resources
function fetchUserData(userId) {
  console.log(`Requesting user data ${userId}...`);
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`User data ${userId} received`);
      resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });
    }, 1000 + Math.random() * 1000); // Random time between 1-2 seconds
  });
}

function fetchUserPosts(userId) {
  console.log(`Requesting posts for user ${userId}...`);
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`Posts for user ${userId} received`);
      resolve([
        { id: 1, title: `Post 1 from user ${userId}` },
        { id: 2, title: `Post 2 from user ${userId}` }
      ]);
    }, 1200 + Math.random() * 1000); // Random time between 1.2-2.2 seconds
  });
}

function fetchUserFollowers(userId) {
  console.log(`Requesting followers for user ${userId}...`);
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`Followers for user ${userId} received`);
      resolve([101, 102, 103]);
    }, 800 + Math.random() * 1000); // Random time between 0.8-1.8 seconds
  });
}

console.time('Total loading time');

// Using Promise.all to execute all requests in parallel
const userId = 42;
Promise.all([
  fetchUserData(userId),
  fetchUserPosts(userId),
  fetchUserFollowers(userId)
])
  .then(([userData, userPosts, userFollowers]) => {
    console.log('\nAll data was successfully loaded!');
    console.log('User data:', userData);
    console.log('Posts:', userPosts);
    console.log('Followers:', userFollowers.length);
    
    console.timeEnd('Total loading time');
  })
  .catch(error => {
    console.error('Error loading data:', error);
    console.timeEnd('Total loading time');
  });

console.log('\nRequesting all data in parallel...');
\end{lstlisting}
\end{macterminal}

\textbf{Important features of Promise.all():}
\begin{itemize}
    \item Takes an array of promises and returns a single promise.
    \item The resulting promise resolves with an array of all results, in the same order as the original promises.
    \item If \textbf{any} of the promises is rejected, \texttt{\textcolor{accentColor}{Promise.all()}} is immediately rejected with that error, without waiting for the others.
    \item All promises execute in parallel, potentially improving performance compared to sequential execution.
\end{itemize}

\subsection{Promise.race(): The First Winner}

Sometimes, we only need the result of the first promise that completes, whether with success or error. \texttt{\textcolor{accentColor}{Promise.race()}} is perfect for these cases.

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|05_promise_race.js|.
    \item Open your terminal and run: \verb|node 05_promise_race.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 05_promise_race.js ---
// Simulates searching for a product across different services with varying times
function searchAmazon(productName) {
  console.log(`Searching for "${productName}" on Amazon...`);
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`Amazon responded`);
      resolve({
        source: 'Amazon',
        price: 29.99,
        inStock: true
      });
    }, 1500 + Math.random() * 1000); // 1.5-2.5 seconds
  });
}

function searchEbay(productName) {
  console.log(`Searching for "${productName}" on eBay...`);
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`eBay responded`);
      resolve({
        source: 'eBay',
        price: 26.50,
        inStock: true
      });
    }, 800 + Math.random() * 2000); // 0.8-2.8 seconds
  });
}

function searchLocalStore(productName) {
  console.log(`Searching for "${productName}" in local store...`);
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`Local store responded`);
      resolve({
        source: 'Local Store',
        price: 32.99,
        inStock: true
      });
    }, 500 + Math.random() * 1000); // 0.5-1.5 seconds
  });
}

// Adding a timeout to cancel if all searches take too long
function timeout(ms) {
  return new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`Timeout after ${ms}ms`));
    }, ms);
  });
}

const productName = "Bluetooth Headphones";
console.log(`\nSearching for the best price for: ${productName}`);
console.time('Search time');

// Race between sources and a timeout
Promise.race([
  searchAmazon(productName),
  searchEbay(productName),
  searchLocalStore(productName),
  timeout(2000) // Cancel after 2 seconds
])
  .then(result => {
    console.log(`\nWe have a winner!`);
    console.log(`${result.source} was the fastest to respond`);
    console.log(`Price: $${result.price}`);
    console.timeEnd('Search time');
  })
  .catch(error => {
    console.error(`\nError: ${error.message}`);
    console.timeEnd('Search time');
  });

console.log('\nSearch in progress across all sources...');
\end{lstlisting}
\end{macterminal}

\textbf{Important features of Promise.race():}
\begin{itemize}
    \item Takes an array of promises and returns a single promise.
    \item The resulting promise resolves or rejects with the value of the first promise that resolves or rejects.
    \item Useful for setting timeouts, choosing the fastest data source, or implementing redundancy patterns.
    \item Unlike \texttt{\textcolor{accentColor}{Promise.all()}}, only the first settled promise matters; the others are ignored.
\end{itemize}

\section{Additional Promise Methods: allSettled, any}

JavaScript has added additional methods to address specific use cases beyond \texttt{\textcolor{accentColor}{Promise.all()}} and \texttt{\textcolor{accentColor}{Promise.race()}}.

\subsection{Promise.allSettled(): Waiting for Everything to Finish}

\texttt{\textcolor{accentColor}{Promise.allSettled()}} waits for all promises to complete, regardless of whether they resolve or reject, and returns an array with the results of each one. It's ideal when we need to process all results, even if some fail.

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|06_promise_allsettled.js|.
    \item Open your terminal and run: \verb|node 06_promise_allsettled.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 06_promise_allsettled.js ---
// We simulate different network operations that may succeed or fail
function fetchDataFromServer(serverId) {
  return new Promise((resolve, reject) => {
    const serverSuccessRate = {
      'EU': 0.95, // 95% success rate
      'US': 0.98, // 98% success rate
      'ASIA': 0.85, // 85% success rate
    };
    
    setTimeout(() => {
      // Simulate success or failure based on predefined rates
      const success = Math.random() < (serverSuccessRate[serverId] || 0.5);
      if (success) {
        resolve({
          serverId,
          data: `Data from server ${serverId}`,
          timestamp: new Date().toISOString()
        });
      } else {
        reject(new Error(`Error connecting to server ${serverId}`));
      }
    }, 1000 + Math.random() * 1000);
  });
}

const serverRequests = [
  fetchDataFromServer('EU'),
  fetchDataFromServer('US'),
  fetchDataFromServer('ASIA'),
  // Adding a promise that will always fail to demonstrate
  new Promise((_, reject) => setTimeout(() => reject(new Error('Server offline')), 1500)),
];

console.log('Requesting data from multiple servers...\n');

Promise.allSettled(serverRequests)
  .then(results => {
    console.log('All requests completed (successful or failed)');
    
    // Count successful and failed results
    const fulfilled = results.filter(r => r.status === 'fulfilled');
    const rejected = results.filter(r => r.status === 'rejected');
    
    console.log(`\nResults: ${fulfilled.length} successful, ${rejected.length} failed`);
    
    // Processing successful results
    console.log('\nRetrieved data:');
    fulfilled.forEach((result, index) => {
      console.log(`${index + 1}. Server ${result.value.serverId}: ${result.value.data}`);
    });
    
    // Logging errors
    console.log('\nErrors found:');
    rejected.forEach((result, index) => {
      console.log(`${index + 1}. Error: ${result.reason.message}`);
    });
  });

console.log('Code continues to execute while requests are being processed...');
\end{lstlisting}
\end{macterminal}

\textbf{Important features of Promise.allSettled():}
\begin{itemize}
    \item Waits for all promises to finish, regardless of the outcome.
    \item The resulting promise never rejects.
    \item Returns an array of objects describing the result of each promise:
    \begin{itemize}
        \item For resolved promises: \verb|{ status: 'fulfilled', value: result }|
        \item For rejected promises: \verb|{ status: 'rejected', reason: error }|
    \end{itemize}
    \item Ideal for operations where we want to try everything and then process the results and errors together.
\end{itemize}

\subsection{Promise.any(): The First Success}

\texttt{\textcolor{accentColor}{Promise.any()}} is similar to \texttt{\textcolor{accentColor}{Promise.race()}} but only considers promises that resolve, ignoring rejected ones until all are rejected.

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|07_promise_any.js|.
    \item Open your terminal and run: \verb|node 07_promise_any.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 07_promise_any.js ---
// Simulate loading images from different CDNs with varying times and reliability
function loadImageFromCDN(cdnName, reliability = 1.0) {
  console.log(`Attempting to load image from ${cdnName}...`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // Simulate success or failure based on reliability factor
      const success = Math.random() <= reliability;
      
      if (success) {
        console.log(`[SUCCESS] ${cdnName}: Image loaded successfully`);
        resolve({
          cdn: cdnName,
          url: `https://${cdnName.toLowerCase()}.example.com/image.jpg`,
          loadTime: Math.floor(Date.now() - startTime) + 'ms'
        });
      } else {
        console.log(`[ERROR] ${cdnName}: Error loading image`);
        reject(new Error(`Error loading from ${cdnName}`));
      }
    }, 1000 + Math.random() * 2000); // 1-3 seconds
  });
}

const startTime = Date.now();
console.log('Starting image loading from multiple CDNs...\n');

// Try loading from various CDNs with different reliability
Promise.any([
  loadImageFromCDN('PrimeCDN', 0.7),    // 70% reliability
  loadImageFromCDN('FastNetwork', 0.5), // 50% reliability
  loadImageFromCDN('BackupCDN', 0.9)    // 90% reliability
])
  .then(result => {
    console.log(`\n[IMAGE] Image loaded successfully!`);
    console.log(`Source: ${result.cdn}`);
    console.log(`URL: ${result.url}`);
    console.log(`Load time: ${result.loadTime}`);
  })
  .catch(error => {
    // AggregateError is a new type that groups all errors when all promises fail
    console.error('\n[ERROR] No CDN could load the image');
    console.error(`Errors found: ${error.errors.length}`);
    error.errors.forEach((err, i) => {
      console.error(`  ${i + 1}. ${err.message}`);
    });
  });

console.log('Attempting to load the image...');
\end{lstlisting}
\end{macterminal}

\textbf{Important features of Promise.any():}
\begin{itemize}
    \item Resolves as soon as one of the promises resolves successfully.
    \item Ignores rejections until all promises are rejected.
    \item If all promises are rejected, it rejects with an \texttt{\textcolor{accentColor}{AggregateError}} that contains all the errors.
    \item Useful when we have multiple sources for the same resource and want to use the first one that succeeds.
\end{itemize}

\section{Conclusions from Part 2}

In this second part of our series on JavaScript Promises, we've explored advanced techniques that allow managing complex asynchronous flows:

\begin{itemize}
    \item \textbf{\textcolor{accentColor}{Promise chaining:}} Allows creating sequences of ordered and clean asynchronous operations, passing data from one operation to the next.
    
    \item \textbf{\textcolor{accentColor}{Promise.all():}} Executes multiple promises in parallel and waits for all of them to complete successfully, optimizing the total wait time.
    
    \item \textbf{\textcolor{accentColor}{Promise.race():}} Returns the result of the first promise that settles, ideal for setting timeouts or choosing the fastest source.
    
    \item \textbf{\textcolor{accentColor}{Promise.allSettled():}} Waits for all promises to complete regardless of outcome, allowing processing of both successes and failures.
    
    \item \textbf{\textcolor{accentColor}{Promise.any():}} Returns the result of the first promise that resolves successfully, ignoring ones that fail until all fail.
\end{itemize}

These tools provide the necessary flexibility to implement complex and robust asynchronous patterns that can adapt to different scenarios and requirements of modern applications.

In the next part, we'll explore how promises integrate with modern \texttt{\textcolor{accentColor}{async/await}} syntax, which further simplifies writing and reading asynchronous code, making it almost as intuitive as traditional synchronous code.

\section{References}

\begin{itemize}
    \item MDN Web Docs. (2025). \textit{Using Promises}. \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises}{Link}
    
    \item MDN Web Docs. (2025). \textit{Promise methods}. \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#Static_methods}{Link}
    
    \item ECMA International. (2025). \textit{ECMAScript 2026 Language Specification: Promise Objects}. \href{https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-objects}{Link}
    
    \item Archibald, J. (2023). \textit{JavaScript Promises: An Introduction}. Google Developers. \href{https://web.dev/articles/promises}{Link}
    
    \item Simpson, K. (2023). \textit{You Don't Know JS Yet: Async \& Performance (2nd Edition)}. O'Reilly Media.

    \item This article was translated, edited, and written in collaboration with AI. If you find any inconsistencies or have suggestions for improvement, please don't hesitate to open an issue in our \href{https://github.com/asanchezyali/social-media-posts}{GitHub} repository or reach out directly.
\end{itemize}

\section{Explore My Other Posts}
\vspace{10pt}
\begin{tikzpicture}
  % Section background - increased height slightly to ensure all content fits
  \fill[color=terminalBg, rounded corners=5pt] (0,0) rectangle (\textwidth,-5);
  
  % Calculate width available for text (total width minus QR code width minus margins)
  \pgfmathsetmacro{\availableWidth}{\textwidth-4cm}
  
  % Left column content
  \begin{scope}
    % Section title
    \node[text=accentColor, font=\Large\bfseries, anchor=north west] at (0.5cm,-0.5cm) {Enjoyed This Content?};
    
    % Subtitle
    \node[text=primaryColor, font=\normalsize, anchor=north west] at (0.5cm,-1.2cm) {Don't miss my previous post about:};
    
    % Node.js Streams Part 1 title - with highlighted style and limited width
\node[text=secondaryColor, font=\large\bfseries, anchor=north west, text width=\availableWidth] at (0.5cm,-1.9cm)
{\color{accentColor}Understanding JavaScript Promises: \color{primaryColor} Part 1/3};
    
    % Brief description of the post - with limited width and adjusted position
    \node[text=jsSecondary, font=\normalsize, text width=\availableWidth, anchor=north west] at (0.5cm,-3.1cm) {
      Learn the fundamental concepts of promises in JavaScript and how they help you effectively manage asynchronous operations.
    };
  \end{scope}
  
  % QR Code on the right - vertically centered
  \node[anchor=center] at ({\textwidth-1.5cm}, {-2.5cm}) {
    \qrcode[height=2.2cm]{https://www.linkedin.com/feed/}
  };
  
\end{tikzpicture}
\vspace{5pt}

\clearpage
\thispagestyle{empty}
\finalpagecontents

\end{document}