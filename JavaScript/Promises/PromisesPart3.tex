% PromisesPart3.tex - Modern Asynchronous JavaScript with async/await
\documentclass[12pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[letterpaper, margin=1in, bottom=2.5in, top=2.2in]{geometry}
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\setlength{\footskip}{72pt}

% Import all the same packages and setup as Parts 1-2
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{anyfontsize}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\usepackage{sourcesanspro}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{fontawesome5}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{mdframed}
\usepackage{qrcode}
\usetikzlibrary{calc,shapes,positioning}
\usepackage{eso-pic}

\AtBeginDocument{\color{primaryColor}}

% Colors updated with JavaScript brand colors
\definecolor{bgColor}{RGB}{13, 17, 23}  % Dark background similar to JS docs
\definecolor{primaryColor}{RGB}{255, 255, 255}  % White text for better contrast
\definecolor{accentColor}{RGB}{255, 220, 60}  % Brighter JavaScript Yellow
\definecolor{jsSecondary}{RGB}{180, 180, 180}  % Light gray as secondary color
\definecolor{secondaryColor}{RGB}{230, 235, 240}  % Almost white gray
\definecolor{terminalBg}{RGB}{22, 22, 22}  % Terminal background
\definecolor{terminalFrame}{RGB}{40, 40, 40}  % Terminal frame
\definecolor{lineNumberColor}{RGB}{100, 100, 100}  % Line number color
\definecolor{dividerColor}{RGB}{120, 130, 150}  % Brighter divider color

% Code colors
\definecolor{codeTextColor}{RGB}{255, 255, 255}  % Pure white for basic text
\definecolor{codeKeywordColor}{RGB}{97, 175, 239}  % Light blue for keywords
\definecolor{codeCommentColor}{RGB}{121, 192, 120}  % Green for comments
\definecolor{codeStringColor}{RGB}{255, 220, 60}  % JS Yellow for strings
\definecolor{codeMethodColor}{RGB}{255, 160, 122}  % Light orange for methods
\definecolor{codeFunctionColor}{RGB}{230, 180, 80}  % Golden yellow for functions
\definecolor{codeNumberColor}{RGB}{180, 230, 180}  % Light green for numbers

\pagecolor{bgColor}

\hypersetup{
    colorlinks=true,
    linkcolor=accentColor,
    filecolor=accentColor,
    urlcolor=accentColor,
}

% Define JavaScript language for listings with async/await keywords
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, let, const, class, export, import, yield, async, await, Promise, resolve, reject},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]"
}

% Listings configuration using JavaScript as default
\lstset{
  language=JavaScript,
  basicstyle=\ttfamily\bfseries\color{codeTextColor},
  backgroundcolor=\color{terminalBg},
  commentstyle=\color{codeCommentColor},
  keywordstyle=\color{codeKeywordColor},
  stringstyle=\color{codeStringColor},
  numberstyle=\color{lineNumberColor},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  showstringspaces=false,
  frame=none,
  xleftmargin=15pt,
  xrightmargin=0pt,
  aboveskip=5pt,
  belowskip=5pt,
  numbers=left,
  numbersep=8pt,
  extendedchars=true,
  keepspaces=true,
  columns=flexible,
  lineskip=2pt,
  emph={[2]require,createReadStream,createWriteStream,pipe,on,once,createGzip,pipeline,Transform,Readable,Writable,Duplex, setTimeout, console, Error, Math, JSON},
  emphstyle={[2]\color{codeFunctionColor}}
}

\newenvironment{macterminal}{%
    \begin{mdframed}[
        linecolor=terminalFrame,
        backgroundcolor=terminalBg,
        roundcorner=5pt,
        skipabove=5pt,
        skipbelow=5pt,
        linewidth=1pt,
        innertopmargin=5pt,
        frametitle={%
            \tikz[baseline=(current bounding box.east), outer sep=0pt]{
                \fill[red!80!black] (0,0) circle (5pt);
                \fill[yellow!80!black] (0.7,0) circle (5pt);
                \fill[green!70!black] (1.4,0) circle (5pt);
            }
        },
        frametitlealignment=\raggedright,
        frametitleaboveskip=8pt,
        frametitlebelowskip=0pt,
    ]
}{%
    \end{mdframed}%
}

\newcommand{\verspace}{\vspace{5pt}}
\newcommand{\languagetag}[1]{
    \begin{tikzpicture}[baseline]
        \node[fill=accentColor, text=bgColor, rounded corners=5pt, inner sep=7pt] {
            {\normalsize\textbf{#1}}
        };
    \end{tikzpicture}
}

% Title formatting
\titleformat{\section}
  {\LARGE\bfseries\color{primaryColor}}
  {\thesection. }
  {0pt}
  {}
  []

\titleformat{\subsection}
  {\Large\bfseries\color{accentColor}}
  {\thesubsection. }
  {0pt}
  {}
  []

\titleformat{\subsubsection}
  {\large\bfseries\color{primaryColor}}
  {\thesubsubsection. }
  {0pt}
  {}
  []

\titlespacing*{\section}{0pt}{18pt}{8pt}
\titlespacing*{\subsection}{0pt}{12pt}{5pt}
\titlespacing*{\subsubsection}{0pt}{8pt}{3pt}

% Header and footer setup
\pagestyle{fancy}
\fancyhf{}

\fancyhead[L]{
    \begin{tikzpicture}[remember picture, overlay]
        \fill[accentColor, rounded corners=3pt] (0,0) rectangle (2.2cm,0.7cm);
        \node[text=bgColor, font=\bfseries] at (1.1cm,0.35cm) {NODE.JS};
        \fill[secondaryColor] (2.35cm,0.1cm) rectangle (2.40cm,0.6cm);
        \node[text=primaryColor, font=\bfseries, anchor=west] at (2.35cm,0.35cm) {PROMISES};
    \end{tikzpicture}
}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0.2pt}
\renewcommand{\footruleskip}{1cm}

\fancyfoot[C]{
    \vspace*{0.1cm}
    \noindent
    \begin{minipage}{\textwidth}
        \begin{flushleft}
            % Profile photo
            \raisebox{0.7cm}{
            \begin{tikzpicture}[baseline]
                \path[fill=bgColor] (0,0) circle (0.6cm);
                \clip (0,0) circle (0.6cm);
                \node at (0,0) {
                    \includegraphics[width=1.2cm,height=1.2cm]{../../Images/profile-image.jpeg}
                };
            \end{tikzpicture}
            }
            % Profile information
            \begin{minipage}[b]{0.5\textwidth}
                {\large\bfseries\color{primaryColor}Alejandro Sánchez Yalí}
                \par\vspace{1pt}
                {\small\color{secondaryColor}Software Developer | AI \& Blockchain Enthusiast}
                \par\vspace{1pt}
                {\small\color{accentColor}\faGlobe\hspace{5pt}\color{secondaryColor}www.asanchezyali.com}
            \end{minipage}
        \end{flushleft}
        \vspace{6pt}
    \end{minipage}
}

\fancypagestyle{plain}{
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \renewcommand{\footrulewidth}{0pt}
}

\renewcommand{\labelitemi}{\textcolor{accentColor}{$\bullet$}}
\renewcommand{\labelitemii}{\textcolor{secondaryColor}{$\circ$}}

\usepackage{relsize}
\AtBeginDocument{\relsize{1}}

\newcommand{\BackgroundPic}{%
    \put(0,0){%
        \begin{tikzpicture}[remember picture, overlay]
            \node[inner sep=0pt] at (current page.center) {
                \includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio=false]{../../Images/Intense Focus at Gaming Event.jpeg}
            };
            \fill[black, opacity=0.7] (current page.south west) rectangle (current page.north east);
        \end{tikzpicture}%
    }%
}

% Command for elegant QR
\newcommand{\elegantqr}[2]{
    \qrcode[height=2.5cm]{#1}
    \\[0.1cm]
    {\hspace{0.2cm}\color{primaryColor}\small #2\par}
}

\newcommand{\titlepagecontents}{%
    \AddToShipoutPicture*{\BackgroundPic}
    \vspace*{2cm}
    \begin{flushleft}
    \languagetag{JavaScript}\\[0.4cm]
    {\fontsize{38}{52}\bfseries\color{primaryColor}Understanding \color{accentColor}JavaScript\\\color{accentColor}Promises\par}
    \vspace{0.3cm}
    {\fontsize{18}{52}\color{secondaryColor}Modern Asynchronous JavaScript \\ Part 3/3\par}
    \vspace{0.3cm}
    {\color{secondaryColor}\today\par}
    \vspace{1.8cm}
    \elegantqr{https://github.com/asanchezyali/social-media-posts/tree/main/JavaScript/Promises}{Source Code}
    \end{flushleft}
}

\newcommand{\finalpagecontents}{%
    \AddToShipoutPicture*{\BackgroundPic}
    \vspace*{3cm}
    \begin{flushleft}
    \languagetag{Feedback}\\[0.4cm]
    {\fontsize{46}{52}\bfseries\color{primaryColor}Found this \color{accentColor}helpful?\par}
    \vspace{0.3cm}
    {\fontsize{18}{52}\color{secondaryColor}Save, comment and share\par}  
    \vspace{0.3cm}
    {\color{secondaryColor}\today\par}
    \end{flushleft}
}

\begin{document}
\setlength{\parindent}{0pt}
\begin{titlepage}
    \titlepagecontents
\end{titlepage}

\section{async/await: The Evolution of Promises}

After mastering the basics of promises and their advanced patterns, it's time to explore \texttt{\textcolor{accentColor}{async/await}}, a modern syntax that makes asynchronous code even more readable and maintainable. This feature, built on top of promises, allows us to write asynchronous code that looks and behaves more like synchronous code.

\subsection{Understanding async/await}

The \texttt{\textcolor{accentColor}{async}} and \texttt{\textcolor{accentColor}{await}} keywords provide a more elegant way to work with promises:

\begin{itemize}
    \item \texttt{\textcolor{accentColor}{async}}: Declares that a function returns a promise
    \item \texttt{\textcolor{accentColor}{await}}: Pauses execution until a promise settles
\end{itemize}

Let's see how this transforms our promise-based code:

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|08_async_await_basics.js|
    \item Open your terminal and run: \verb|node 08_async_await_basics.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 08_async_await_basics.js ---
// Simulating an API call that returns user data
async function fetchUserData(userId) {
  console.log(`Fetching user data for ID: ${userId}...`);
  
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Simulate success/failure
  if (userId <= 0) {
    throw new Error('Invalid user ID');
  }
  
  return {
    id: userId,
    name: 'Alex',
    email: `user${userId}@example.com`
  };
}

// Using async/await with try/catch
async function displayUserProfile(userId) {
  console.log('Starting user profile retrieval...');
  
  try {
    const userData = await fetchUserData(userId);
    console.log('User data retrieved successfully:');
    console.log(userData);
  } catch (error) {
    console.error('Error fetching user data:', error.message);
  }
  
  console.log('Profile display operation completed.');
}

// Execute our async function
console.log('Before calling async function');
displayUserProfile(123)
  .then(() => console.log('Async operation chain completed.'));
console.log('After calling async function (executes immediately)');

// Try with an invalid ID to see error handling
setTimeout(() => {
  console.log('\nTrying with invalid ID:');
  displayUserProfile(-1);
}, 2000);
\end{lstlisting}
\end{macterminal}

Key points about \texttt{\textcolor{accentColor}{async/await}}:
\begin{itemize}
    \item An \texttt{\textcolor{accentColor}{async}} function always returns a promise
    \item \texttt{\textcolor{accentColor}{await}} can only be used inside an \texttt{\textcolor{accentColor}{async}} function
    \item The function pauses at each \texttt{\textcolor{accentColor}{await}} until the promise resolves
    \item Error handling uses familiar \texttt{\textcolor{accentColor}{try/catch}} syntax
    \item The code looks more like traditional synchronous code
\end{itemize}

\subsection{Error Handling Patterns with async/await}

When working with multiple asynchronous operations, proper error handling becomes crucial. Let's explore some practical patterns:

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|09_error_handling_patterns.js|
    \item Open your terminal and run: \verb|node 09_error_handling_patterns.js|
\end{itemize}

\begin{macterminal}
\begin{lstlisting}
// --- 09_error_handling_patterns.js ---
// Simulating database operations
async function connectToDatabase() {
  console.log('Connecting to database...');
  await new Promise(resolve => setTimeout(resolve, 500));
  return { connected: true };
}

async function queryDatabase(connection, query) {
  console.log(`Executing query: ${query}`);
  await new Promise(resolve => setTimeout(resolve, 800));
  
  if (!connection.connected) {
    throw new Error('Database connection lost');
  }
  
  if (query.includes('invalid')) {
    throw new Error('Invalid SQL query');
  }
  
  return [`Result 1 for ${query}`, `Result 2 for ${query}`];
}

async function processResults(results) {
  console.log('Processing results...');
  await new Promise(resolve => setTimeout(resolve, 300));
  return results.map(r => r.toUpperCase());
}

// Pattern 1: Sequential operations with proper cleanup
async function performDatabaseOperation(query) {
  let connection = null;
  
  try {
    // Establish connection
    connection = await connectToDatabase();
    
    // Execute query
    const results = await queryDatabase(connection, query);
    
    // Process results
    const processedResults = await processResults(results);
    
    return processedResults;
  } catch (error) {
    console.error('Operation failed:', error.message);
    throw error; // Re-throw to let caller handle it
  } finally {
    if (connection) {
      console.log('Closing database connection...');
      connection.connected = false;
    }
  }
}

// Pattern 2: Parallel operations with Promise.all
async function executeMultipleQueries(queries) {
  try {
    const connection = await connectToDatabase();
    
    console.log('Executing queries in parallel...');
    const results = await Promise.all(
      queries.map(query => queryDatabase(connection, query))
    );
    
    const processedResults = await Promise.all(
      results.map(result => processResults(result))
    );
    
    return processedResults;
  } catch (error) {
    console.error('Batch operation failed:', error.message);
    throw error;
  }
}

// Pattern 3: Retry mechanism
async function executeWithRetry(operation, maxAttempts = 3) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      
      console.log(`Attempt ${attempt} failed, retrying...`);
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, attempt) * 100)
      );
    }
  }
}

// Demo the patterns
async function demonstratePatterns() {
  console.log('--- Pattern 1: Sequential with Cleanup ---');
  try {
    const results = await performDatabaseOperation('SELECT * FROM users');
    console.log('Success:', results);
  } catch (error) {
    console.log('Handler caught:', error.message);
  }
  
  console.log('\n--- Pattern 2: Parallel Operations ---');
  try {
    const queries = [
      'SELECT * FROM users',
      'SELECT * FROM posts',
      'SELECT * FROM comments'
    ];
    const results = await executeMultipleQueries(queries);
    console.log('Batch results:', results);
  } catch (error) {
    console.log('Batch handler caught:', error.message);
  }
  
  console.log('\n--- Pattern 3: Retry Mechanism ---');
  let failCount = 0;
  const unreliableOperation = async () => {
    failCount++;
    if (failCount < 3) throw new Error('Temporary failure');
    return 'Operation succeeded!';
  };
  
  try {
    const result = await executeWithRetry(unreliableOperation);
    console.log('Final result:', result);
  } catch (error) {
    console.log('Retry handler caught:', error.message);
  }
}

demonstratePatterns();
\end{lstlisting}
\end{macterminal}

These patterns demonstrate several important concepts:

\begin{itemize}
    \item Resource cleanup using \texttt{\textcolor{accentColor}{try/finally}} blocks
    \item Parallel execution while maintaining error handling
    \item Retry mechanisms for transient failures
    \item Proper error propagation to calling code
\end{itemize}

\section{Best Practices and Advanced Patterns}

When working with \texttt{\textcolor{accentColor}{async/await}}, following certain practices can make your code more maintainable and robust:

\subsection{Common Pitfalls and Solutions}

Let's look at some common mistakes and their solutions:

\begin{macterminal}
\begin{lstlisting}
// --- 10_best_practices.js ---
// [BAD] WRONG: Not handling errors
async function wrongErrorHandling() {
  const data = await riskyOperation(); // Unhandled promise rejection!
}

// [GOOD] RIGHT: Proper error handling
async function rightErrorHandling() {
  try {
    const data = await riskyOperation();
    return data;
  } catch (error) {
    console.error('Operation failed:', error);
    throw error; // Re-throw if you want callers to handle it
  }
}

// [BAD] WRONG: Sequential when parallel is possible
async function wrongSequential() {
  const users = await fetchUsers();
  const posts = await fetchPosts();
  const comments = await fetchComments();
}

// [GOOD] RIGHT: Parallel execution when possible
async function rightParallel() {
  const [users, posts, comments] = await Promise.all([
    fetchUsers(),
    fetchPosts(),
    fetchComments()
  ]);
}

// [BAD] WRONG: await in a loop
async function wrongLoop() {
  const ids = [1, 2, 3, 4, 5];
  const results = [];
  for (const id of ids) {
    results.push(await fetchData(id)); // Sequential execution
  }
}

// [GOOD] RIGHT: Map and Promise.all
async function rightLoop() {
  const ids = [1, 2, 3, 4, 5];
  const results = await Promise.all(
    ids.map(id => fetchData(id))
  );
}

// [BAD] WRONG: Not considering race conditions
let data;
async function wrongRaceCondition() {
  data = await fetchData(); // Global state modification
}

// [GOOD] RIGHT: Proper state management
class DataManager {
  constructor() {
    this.data = null;
    this.loading = false;
  }
  
  async fetchData() {
    if (this.loading) return this.data;
    
    this.loading = true;
    try {
      this.data = await fetchData();
      return this.data;
    } finally {
      this.loading = false;
    }
  }
}
\end{lstlisting}
\end{macterminal}

Best practices to follow:
\begin{itemize}
    \item Always handle errors appropriately
    \item Use \texttt{\textcolor{accentColor}{Promise.all}} for parallel operations when possible
    \item Avoid \texttt{\textcolor{accentColor}{await}} in loops unless sequential execution is required
    \item Consider race conditions in shared state
    \item Use proper abstraction and encapsulation
\end{itemize}

\section{Real-World Examples}

Let's explore some practical examples that combine everything we've learned about promises and async/await:

\begin{macterminal}
\begin{lstlisting}
// --- 11_real_world_examples.js ---
// Example 1: API Request with Timeout and Retry
async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, { signal: controller.signal });
    const data = await response.json();
    return data;
  } finally {
    clearTimeout(timeoutId);
  }
}

async function fetchWithRetry(url, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fetchWithTimeout(url);
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, i) * 1000)
      );
    }
  }
}

// Example 2: Resource Pool
class ResourcePool {
  constructor(factory, poolSize = 5) {
    this.resources = Array(poolSize).fill(null);
    this.factory = factory;
    this.available = [...Array(poolSize).keys()];
    this.waiting = [];
  }
  
  async acquire() {
    if (this.available.length > 0) {
      const index = this.available.pop();
      if (!this.resources[index]) {
        this.resources[index] = await this.factory();
      }
      return { resource: this.resources[index], index };
    }
    
    return new Promise(resolve => {
      this.waiting.push(resolve);
    });
  }
  
  release({ resource, index }) {
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift();
      resolve({ resource, index });
    } else {
      this.available.push(index);
    }
  }
}

// Example 3: Batch Processing with Rate Limiting
async function processBatch(items, batchSize = 3, delay = 1000) {
  const results = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(item => processItem(item))
    );
    results.push(...batchResults);
    
    if (i + batchSize < items.length) {
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  return results;
}

// Example 4: Event to Promise conversion
function eventToPromise(emitter, successEvent, errorEvent) {
  return new Promise((resolve, reject) => {
    const success = (...args) => {
      cleanup();
      resolve(...args);
    };
    
    const error = (...args) => {
      cleanup();
      reject(...args);
    };
    
    const cleanup = () => {
      emitter.removeListener(successEvent, success);
      emitter.removeListener(errorEvent, error);
    };
    
    emitter.on(successEvent, success);
    emitter.on(errorEvent, error);
  });
}
\end{lstlisting}
\end{macterminal}

These examples demonstrate:
\begin{itemize}
    \item Combining timeouts with fetch requests
    \item Managing resource pools asynchronously
    \item Rate-limiting batch operations
    \item Converting event-based APIs to promises
\end{itemize}

\section{Performance Considerations}

When working with async/await and promises, keep these performance aspects in mind:

\begin{itemize}
    \item \textbf{Memory Usage:} Promises keep references to their results/errors until all handlers complete
    \item \textbf{Microtasks:} Promise callbacks run as microtasks, which have priority over regular tasks
    \item \textbf{Stack Traces:} async/await provides better stack traces for debugging compared to raw promises
    \item \textbf{Parallel vs Sequential:} Use Promise.all when operations can run in parallel
\end{itemize}

\section{Conclusions}

Throughout this series on JavaScript Promises, we've covered:

\begin{itemize}
    \item \textbf{Part 1:} Promise fundamentals, states, and basic handling
    \item \textbf{Part 2:} Advanced promise patterns and combination methods
    \item \textbf{Part 3:} Modern async/await syntax and real-world applications
\end{itemize}

Key takeaways:
\begin{itemize}
    \item Promises provide a robust foundation for handling asynchronous operations
    \item async/await simplifies asynchronous code while maintaining promise benefits
    \item Error handling becomes more intuitive with try/catch syntax
    \item Real-world applications often combine multiple patterns
\end{itemize}

Understanding these concepts is crucial for modern JavaScript development, enabling you to write maintainable, efficient, and reliable asynchronous code.

\section{References}

\begin{itemize}
    \item MDN Web Docs. (2025). \textit{async function}. \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}{Link}
    
    \item MDN Web Docs. (2025). \textit{await}. \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await}{Link}
    
    \item ECMA International. (2025). \textit{ECMAScript 2026: Async Functions}. \href{https://tc39.es/ecma262/#sec-async-function-definitions}{Link}
    
    \item Archibald, J. (2023). \textit{JavaScript Async/Await: The Good Parts}. \href{https://web.dev/articles/async-functions}{Link}
    
    \item Simpson, K. (2023). \textit{You Don't Know JS Yet: Async \& Performance (2nd Edition)}. O'Reilly Media.

    \item This article was translated, edited, and written in collaboration with AI. If you find any inconsistencies or have suggestions for improvement, please don't hesitate to open an issue in our \href{https://github.com/asanchezyali/social-media-posts}{GitHub} repository or reach out directly.
\end{itemize}

\section{Explore My Other Posts}
\vspace{10pt}
\begin{tikzpicture}
  \fill[color=terminalBg, rounded corners=5pt] (0,0) rectangle (\textwidth,-5);
  
  \pgfmathsetmacro{\availableWidth}{\textwidth-4cm}
  
  \begin{scope}
    \node[text=accentColor, font=\Large\bfseries, anchor=north west] at (0.5cm,-0.5cm) {Enjoyed This Content?};
    
    \node[text=primaryColor, font=\normalsize, anchor=north west] at (0.5cm,-1.2cm) {Don't miss my previous post about:};
    
    \node[text=secondaryColor, font=\large\bfseries, anchor=north west, text width=\availableWidth] at (0.5cm,-1.9cm)
    {\color{accentColor}Understanding JavaScript Promises: \color{primaryColor}Part 2/3};
    
    \node[text=jsSecondary, font=\normalsize, text width=\availableWidth, anchor=north west] at (0.5cm,-3.1cm) {
      Learn about advanced Promise patterns like Promise.all(), Promise.race(), and how to manage multiple asynchronous operations effectively.
    };
  \end{scope}
  
  \node[anchor=center] at ({\textwidth-1.5cm}, {-2.5cm}) {
    \qrcode[height=2.2cm]{https://www.linkedin.com/feed/}
  };
  
\end{tikzpicture}
\vspace{5pt}

\clearpage
\thispagestyle{empty}
\finalpagecontents

\end{document}