\input{../Headers/Headers.tex}

\newcommand{\BackgroundPic}{%
    \put(0,0){%
        \begin{tikzpicture}[remember picture, overlay]
            \node[inner sep=0pt] at (current page.center) {
                \includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio=false]{../../Images/Intense Focus at Gaming Event.jpeg}
            };
            \fill[black, opacity=0.7] (current page.south west) rectangle (current page.north east);
        \end{tikzpicture}%
    }%
}

\newcommand{\titlepagecontents}{%
    \AddToShipoutPicture*{\BackgroundPic}
    \vspace*{2cm}
    \begin{flushleft}
    \languagetag{JavaScript}\\[0.4cm]
    {\fontsize{38}{52}\bfseries\color{primaryColor}Understanding \color{accentColor}JavaScript\\\color{accentColor}Promises\par}
    \vspace{0.3cm}
    {\fontsize{18}{52}\color{secondaryColor}Modern Asynchronous JavaScript \\ Part 3/3\par}
    \vspace{0.3cm}
    {\color{secondaryColor}\today\par}
    \vspace{1.8cm}
    \elegantqr{https://github.com/asanchezyali/social-media-posts/tree/main/JavaScript/Promises}{Source Code}
    \end{flushleft}
}

\newcommand{\finalpagecontents}{%
    \AddToShipoutPicture*{\BackgroundPic}
    \vspace*{3cm}
    \begin{flushleft}
    \languagetag{Feedback}\\[0.4cm]
    {\fontsize{46}{52}\bfseries\color{primaryColor}Found this \color{accentColor}helpful?\par}
    \vspace{0.3cm}
    {\fontsize{18}{52}\color{secondaryColor}Save, comment and share\par}  
    \vspace{0.3cm}
    {\color{secondaryColor}\today\par}
    \end{flushleft}
}

\begin{document}
\setlength{\parindent}{0pt}
\begin{titlepage}
    \titlepagecontents
\end{titlepage}

\section{async/await: The Evolution of Promises}

After mastering the basics of promises and their advanced patterns, it's time to explore \code{async/await}, a modern syntax that makes asynchronous code even more readable and maintainable. This feature, built on top of promises, allows us to write asynchronous code that looks and behaves more like synchronous code.

\subsection{Understanding async/await}

The \code{async} and \code{await} keywords provide a more elegant way to work with promises:

\begin{itemize}
    \item \code{async}: Declares that a function returns a promise
    \item \code{await}: Pauses execution until a promise settles
\end{itemize}

Let's see how this transforms our promise-based code:

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|08_async_await_basics.js|
    \item Open your terminal and run: \verb|node 08_async_await_basics.js|
\end{itemize}

\begin{macterminal}
  \lstinputlisting[language=JavaScript]{codes/08_async_await_basics.js}
\end{macterminal}

Key points about \texttt{\textcolor{accentColor}{async/await}}:
\begin{itemize}
    \item An \texttt{\textcolor{accentColor}{async}} function always returns a promise
    \item \texttt{\textcolor{accentColor}{await}} can only be used inside an \texttt{\textcolor{accentColor}{async}} function
    \item The function pauses at each \texttt{\textcolor{accentColor}{await}} until the promise resolves
    \item Error handling uses familiar \texttt{\textcolor{accentColor}{try/catch}} syntax
    \item The code looks more like traditional synchronous code
\end{itemize}

\subsection{Error Handling Patterns with async/await}

When working with multiple asynchronous operations, proper error handling becomes crucial. Let's explore some practical patterns:

\textbf{How to Run:}
\begin{itemize}
    \item Save the code as \verb|09_error_handling_patterns.js|
    \item Open your terminal and run: \verb|node 09_error_handling_patterns.js|
\end{itemize}

\begin{macterminal}
  \lstinputlisting[language=JavaScript]{codes/09_error_handling_patterns.js}
\end{macterminal}

These patterns demonstrate several important concepts:

\begin{itemize}
    \item Resource cleanup using \texttt{\textcolor{accentColor}{try/finally}} blocks
    \item Parallel execution while maintaining error handling
    \item Retry mechanisms for transient failures
    \item Proper error propagation to calling code
\end{itemize}

\section{Best Practices and Advanced Patterns}

When working with \texttt{\textcolor{accentColor}{async/await}}, following certain practices can make your code more maintainable and robust:

\subsection{Common Pitfalls and Solutions}

Let's look at some common mistakes and their solutions:

\begin{macterminal}
  \lstinputlisting[language=JavaScript]{codes/10_best_practices.js}
\end{macterminal}

Best practices to follow:
\begin{itemize}
    \item Always handle errors appropriately
    \item Use \texttt{\textcolor{accentColor}{Promise.all}} for parallel operations when possible
    \item Avoid \texttt{\textcolor{accentColor}{await}} in loops unless sequential execution is required
    \item Consider race conditions in shared state
    \item Use proper abstraction and encapsulation
\end{itemize}

\section{Real-World Examples}

Let's explore some practical examples that combine everything we've learned about promises and async/await:

\begin{macterminal}
\lstinputlisting[language=JavaScript]{codes/11_real_world_examples.js}
\end{macterminal}

These examples demonstrate:
\begin{itemize}
    \item Combining timeouts with fetch requests
    \item Managing resource pools asynchronously
    \item Rate-limiting batch operations
    \item Converting event-based APIs to promises
\end{itemize}

\section{Performance Considerations}

When working with async/await and promises, keep these performance aspects in mind:

\begin{itemize}
    \item \textbf{Memory Usage:} Promises keep references to their results/errors until all handlers complete
    \item \textbf{Microtasks:} Promise callbacks run as microtasks, which have priority over regular tasks
    \item \textbf{Stack Traces:} async/await provides better stack traces for debugging compared to raw promises
    \item \textbf{Parallel vs Sequential:} Use Promise.all when operations can run in parallel
\end{itemize}

\section{Conclusions}

Throughout this series on JavaScript Promises, we've covered:

\begin{itemize}
    \item \textbf{Part 1:} Promise fundamentals, states, and basic handling
    \item \textbf{Part 2:} Advanced promise patterns and combination methods
    \item \textbf{Part 3:} Modern async/await syntax and real-world applications
\end{itemize}

Key takeaways:
\begin{itemize}
    \item Promises provide a robust foundation for handling asynchronous operations
    \item async/await simplifies asynchronous code while maintaining promise benefits
    \item Error handling becomes more intuitive with try/catch syntax
    \item Real-world applications often combine multiple patterns
\end{itemize}

Understanding these concepts is crucial for modern JavaScript development, enabling you to write maintainable, efficient, and reliable asynchronous code.

\section{References}

\begin{itemize}
    \item MDN Web Docs. (2025). \textit{async function}. \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}{Link}
    
    \item MDN Web Docs. (2025). \textit{await}. \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await}{Link}
    
    \item ECMA International. (2025). \textit{ECMAScript 2026: Async Functions}. \href{https://tc39.es/ecma262/#sec-async-function-definitions}{Link}
    
    \item Archibald, J. (2023). \textit{JavaScript Async/Await: The Good Parts}. \href{https://web.dev/articles/async-functions}{Link}
    
    \item Simpson, K. (2023). \textit{You Don't Know JS Yet: Async \& Performance (2nd Edition)}. O'Reilly Media.

    \item This article was translated, edited, and written in collaboration with AI. If you find any inconsistencies or have suggestions for improvement, please don't hesitate to open an issue in our \href{https://github.com/asanchezyali/social-media-posts}{GitHub} repository or reach out directly.
\end{itemize}

\section{Explore My Other Posts}
\vspace{10pt}
\begin{tikzpicture}
  \fill[color=terminalBg, rounded corners=5pt] (0,0) rectangle (\textwidth,-5);
  
  \pgfmathsetmacro{\availableWidth}{\textwidth-4cm}
  
  \begin{scope}
    \node[text=accentColor, font=\Large\bfseries, anchor=north west] at (0.5cm,-0.5cm) {Enjoyed This Content?};
    
    \node[text=primaryColor, font=\normalsize, anchor=north west] at (0.5cm,-1.2cm) {Don't miss my previous post about:};
    
    \node[text=secondaryColor, font=\large\bfseries, anchor=north west, text width=\availableWidth] at (0.5cm,-1.9cm)
    {\color{accentColor}Understanding JavaScript Promises: \color{primaryColor}Part 2/3};
    
    \node[text=jsSecondary, font=\normalsize, text width=\availableWidth, anchor=north west] at (0.5cm,-3.1cm) {
      Learn about advanced Promise patterns like Promise.all(), Promise.race(), and how to manage multiple asynchronous operations effectively.
    };
  \end{scope}
  
  \node[anchor=center] at ({\textwidth-1.5cm}, {-2.5cm}) {
    \qrcode[height=2.2cm]{https://www.linkedin.com/feed/}
  };
  
\end{tikzpicture}
\vspace{5pt}

\clearpage
\thispagestyle{empty}
\finalpagecontents

\end{document}